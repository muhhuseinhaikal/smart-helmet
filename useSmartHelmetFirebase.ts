"use client"

import { useState, useEffect, useCallback } from "react"
import {
  collection,
  onSnapshot,
  doc,
  updateDoc,
  addDoc,
  deleteDoc,
  serverTimestamp,
  query,
  orderBy,
  limit,
  writeBatch,
} from "firebase/firestore"
import { db } from "@/lib/firebase"
import {
  collections,
  helmetDataModel,
  alertDataModel,
  realtimeConfig,
  notificationConfig,
} from "@/config/firebase_config"
import type { HelmetData, AlertData, DataModel } from "@/types/helmet"

export function useSmartHelmetFirebase() {
  const [helmets, setHelmets] = useState<HelmetData[]>([])
  const [alerts, setAlerts] = useState<AlertData[]>([])
  const [loading, setLoading] = useState(true)
  const [error, setError] = useState<string | null>(null)
  const [connectionStatus, setConnectionStatus] = useState<"connected" | "disconnected" | "connecting">("connecting")

  // Validation function
  const validateData = useCallback((data: any, model: DataModel) => {
    const errors: string[] = []

    // Check required fields
    model.required.forEach((field) => {
      if (data[field] === undefined || data[field] === null) {
        errors.push(`${field} is required`)
      }
    })

    // Validate field values
    Object.entries(model.validation).forEach(([field, rules]) => {
      const value = data[field]
      if (value === undefined || value === null) return

      if (Array.isArray(rules)) {
        if (!rules.includes(value)) {
          errors.push(`${field} must be one of: ${rules.join(", ")}`)
        }
      } else if (typeof rules === "object") {
        if (rules.min !== undefined && value < rules.min) {
          errors.push(`${field} must be at least ${rules.min}`)
        }
        if (rules.max !== undefined && value > rules.max) {
          errors.push(`${field} must be at most ${rules.max}`)
        }
      }
    })

    return { isValid: errors.length === 0, errors }
  }, [])

  // Add default values
  const addDefaults = useCallback((data: any, model: DataModel) => {
    return { ...model.defaults, ...data }
  }, [])

  // Real-time helmet listener
  useEffect(() => {
    if (!realtimeConfig.enableRealtime) return

    setConnectionStatus("connecting")

    const helmetsQuery = query(collection(db, collections.helmets), orderBy("updatedAt", "desc"))

    const unsubscribe = onSnapshot(
      helmetsQuery,
      (snapshot) => {
        try {
          const helmetData = snapshot.docs.map((doc) => ({
            id: doc.id,
            ...doc.data(),
          })) as HelmetData[]

          setHelmets(helmetData)
          setConnectionStatus("connected")
          setLoading(false)
          setError(null)

          // Check for alerts based on thresholds
          helmetData.forEach((helmet) => {
            checkHelmetThresholds(helmet)
          })
        } catch (err) {
          console.error("Error processing helmet data:", err)
          setError("Failed to process helmet data")
        }
      },
      (err) => {
        console.error("Firebase connection error:", err)
        setError("Failed to connect to Firebase")
        setConnectionStatus("disconnected")
        setLoading(false)

        // Auto-reconnect logic
        if (realtimeConfig.autoReconnect) {
          setTimeout(() => {
            setConnectionStatus("connecting")
          }, realtimeConfig.retryDelay)
        }
      },
    )

    return () => unsubscribe()
  }, [])

  // Real-time alerts listener
  useEffect(() => {
    if (!realtimeConfig.enableRealtime) return

    const alertsQuery = query(collection(db, collections.alerts), orderBy("createdAt", "desc"), limit(100))

    const unsubscribe = onSnapshot(alertsQuery, (snapshot) => {
      const alertData = snapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      })) as AlertData[]

      setAlerts(alertData)

      // Handle new alerts (browser notifications, sounds, etc.)
      alertData.forEach((alert) => {
        if (!alert.isRead && alert.autoGenerated) {
          handleNewAlert(alert)
        }
      })
    })

    return () => unsubscribe()
  }, [])

  // Check helmet thresholds and generate alerts
  const checkHelmetThresholds = useCallback(async (helmet: HelmetData) => {
    const { thresholds } = notificationConfig

    // Low battery alert
    if (helmet.batteryLevel <= thresholds.lowBattery && helmet.batteryLevel > thresholds.criticalBattery) {
      await addAlert({
        type: "battery",
        message: `Low battery warning for ${helmet.workerName}'s helmet (${helmet.batteryLevel}%)`,
        helmetId: helmet.id,
        priority: "medium",
      })
    }

    // Critical battery alert
    if (helmet.batteryLevel <= thresholds.criticalBattery) {
      await addAlert({
        type: "battery",
        message: `CRITICAL: Very low battery for ${helmet.workerName}'s helmet (${helmet.batteryLevel}%)`,
        helmetId: helmet.id,
        priority: "critical",
      })
    }

    // High temperature alert
    if (helmet.temperature && helmet.temperature >= thresholds.highTemperature) {
      await addAlert({
        type: "temperature",
        message: `High temperature detected for ${helmet.workerName}'s helmet (${helmet.temperature}Â°C)`,
        helmetId: helmet.id,
        priority: "high",
      })
    }

    // Offline timeout alert
    if (helmet.updatedAt) {
      const lastUpdate = helmet.updatedAt.toDate ? helmet.updatedAt.toDate() : new Date(helmet.updatedAt)
      const timeDiff = Date.now() - lastUpdate.getTime()

      if (timeDiff > thresholds.offlineTimeout && helmet.isActive) {
        await addAlert({
          type: "offline",
          message: `${helmet.workerName}'s helmet has been offline for ${Math.round(timeDiff / 60000)} minutes`,
          helmetId: helmet.id,
          priority: "high",
        })
      }
    }
  }, [])

  // Handle new alerts (notifications, sounds, etc.)
  const handleNewAlert = useCallback((alert: AlertData) => {
    // Browser notification
    if (notificationConfig.enablePushNotifications && "Notification" in window) {
      if (Notification.permission === "granted") {
        new Notification(`Smart Helmet Alert: ${alert.type}`, {
          body: alert.message,
          icon: "/helmet-icon.png",
        })
      }
    }

    // Sound alert for critical alerts
    if (alert.priority === "critical") {
      // You can add sound alert logic here
      console.log("ðŸš¨ CRITICAL ALERT:", alert.message)
    }
  }, [])

  // CRUD Operations
  const addHelmet = async (helmetData: Omit<HelmetData, "id">) => {
    try {
      const dataWithDefaults = addDefaults(helmetData, helmetDataModel)
      const validation = validateData(dataWithDefaults, helmetDataModel)

      if (!validation.isValid) {
        throw new Error(`Validation failed: ${validation.errors.join(", ")}`)
      }

      await addDoc(collection(db, collections.helmets), {
        ...dataWithDefaults,
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp(),
      })
    } catch (err) {
      console.error("Error adding helmet:", err)
      throw err
    }
  }

  const updateHelmet = async (helmetId: string, data: Partial<HelmetData>) => {
    try {
      const validation = validateData(data, helmetDataModel)
      if (!validation.isValid) {
        console.warn("Validation warnings:", validation.errors)
      }

      const helmetRef = doc(db, collections.helmets, helmetId)
      await updateDoc(helmetRef, {
        ...data,
        updatedAt: serverTimestamp(),
      })
    } catch (err) {
      console.error("Error updating helmet:", err)
      throw err
    }
  }

  const deleteHelmet = async (helmetId: string) => {
    try {
      await deleteDoc(doc(db, collections.helmets, helmetId))
    } catch (err) {
      console.error("Error deleting helmet:", err)
      throw err
    }
  }

  const addAlert = async (alertData: Omit<AlertData, "id">) => {
    try {
      const dataWithDefaults = addDefaults(alertData, alertDataModel)

      await addDoc(collection(db, collections.alerts), {
        ...dataWithDefaults,
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp(),
      })
    } catch (err) {
      console.error("Error adding alert:", err)
      throw err
    }
  }

  const markAlertAsRead = async (alertId: string) => {
    try {
      const alertRef = doc(db, collections.alerts, alertId)
      await updateDoc(alertRef, {
        isRead: true,
        updatedAt: serverTimestamp(),
      })
    } catch (err) {
      console.error("Error marking alert as read:", err)
      throw err
    }
  }

  // Bulk operations
  const bulkUpdateHelmets = async (updates: Array<{ id: string; data: Partial<HelmetData> }>) => {
    try {
      const batch = writeBatch(db)

      updates.forEach(({ id, data }) => {
        const helmetRef = doc(db, collections.helmets, id)
        batch.update(helmetRef, {
          ...data,
          updatedAt: serverTimestamp(),
        })
      })

      await batch.commit()
    } catch (err) {
      console.error("Error bulk updating helmets:", err)
      throw err
    }
  }

  // Simulate impact for testing
  const simulateImpact = async (helmetId: string) => {
    const helmet = helmets.find((h) => h.id === helmetId)
    if (!helmet) return

    await updateHelmet(helmetId, {
      impactStatus: "warning",
      ledStatus: "red",
      impactCount: (helmet.impactCount || 0) + 1,
    })

    await addAlert({
      type: "impact",
      message: `Impact detected on ${helmet.workerName}'s helmet! Location: ${helmet.location.address}`,
      helmetId: helmetId,
      priority: "high",
    })

    // Reset after 10 seconds
    setTimeout(async () => {
      await updateHelmet(helmetId, {
        impactStatus: "normal",
        ledStatus: helmet.isActive ? "green" : "off",
      })
    }, 10000)
  }

  // Analytics functions
  const getHelmetStats = useCallback(() => {
    return {
      total: helmets.length,
      active: helmets.filter((h) => h.isActive).length,
      offline: helmets.filter((h) => !h.isActive).length,
      lowBattery: helmets.filter((h) => h.batteryLevel <= notificationConfig.thresholds.lowBattery).length,
      totalImpacts: helmets.reduce((sum, h) => sum + (h.impactCount || 0), 0),
      avgBattery:
        helmets.length > 0 ? Math.round(helmets.reduce((sum, h) => sum + h.batteryLevel, 0) / helmets.length) : 0,
      totalWorkingHours: helmets.reduce((sum, h) => sum + (h.workingHours || 0), 0),
      avgSafetyScore:
        helmets.length > 0
          ? Math.round(helmets.reduce((sum, h) => sum + (h.safetyScore || 100), 0) / helmets.length)
          : 100,
    }
  }, [helmets])

  return {
    // Data
    helmets,
    alerts,
    loading,
    error,
    connectionStatus,

    // Stats
    stats: getHelmetStats(),

    // CRUD Operations
    addHelmet,
    updateHelmet,
    deleteHelmet,
    addAlert,
    markAlertAsRead,
    bulkUpdateHelmets,

    // Utilities
    simulateImpact,
    validateData,
    addDefaults,
  }
}
